正则
====

### 什么是正则？

> 正则就是一个规则，用来处理**`字符串`**的规则
> 
> 1、正则匹配
> 
> 编写一个规则，验证某个字符串是否符合这个规则，正则匹配使用的是test方法
> 
> 2、 正则捕获
> 
> 编写一个规则，在一个字符串中把符合规则的内容都获取到，正则捕获使用的方法：正则的exec方法、字符串中的split、replace、match等方法都支持正则

```javascript
var reg = /^$/; //=> 两个斜杠中间包含一些内容就是正则，两个斜杠之间包含的全部内容都是元字符
```

### 正则的元字符和修饰符

> 任何一个正则都是由元字符和修饰符组成的

`修饰符`

+ g(global): 全局匹配
+ i(ignoreCase): 忽略大小写匹配
+ m(multitle): 多行匹配

`元字符`

[量词元字符]

+： 让前面的元字符出现1到多次

?： 出现0到1次

*： 出现0到多次

{n}：出现n次

{n,}：出现n到多次

{n,m}：出现n到m次


[特殊意义的元字符]

\\: 转义字符（把一个普通字符转变为特殊意义的字符，或者把一个有意义字符转换为普通的字符）

.:除了\n（换行符）以外的任意字符

\d: 匹配一个0-9之间的数字

\D: 匹配任意一个非0-9之间的数字（大写字母和小写字母的组合瞧好是反向的）

\w: 匹配一个`0-9或字母或_`之间的字符

\s: 匹配一个任意空白字符

\b: 匹配一个边界符

x|y: 匹配x或y中的一个

[a-z]: 匹配a-z中的任意一个字符

[^a-z]: 和上面的相反，匹配任意一个非a-z的字符

[xyz]: 匹配x或者y或者z中的任意一个字符

[^xyz]: 匹配除了xyz意外的任意字符

(): 正则的小分组，匹配一个小分组（小分组可以理解为大正则中的小正则）

^: 以某一个元字符开始

$: 以某一个元字符结束

?:：只匹配不捕获

?=: 正向预查

?!:负向预查

...

除了以上特殊字符和量词字符，齐钰的都叫做普通元字符：代表本身意义的元字符

### 元字符详细解读

`^ $`

```javascript
var reg = /\d+/; //=> 包含某某某即可
var str = 'abc2018-818';
reg.text(str); //=> true

reg = /^\d+/;
reg.test(str); //=> false

reg = /^\d+$/; //=> 只能是某某某的，这里说明只能是1到多个数字
reg.test(str); //=> false

reg.test('2018'); //=> true
reg.test('2018abc2018'); //=> false
reg.test('1'); //=> true //=> ^或$只是一个修饰或者声明，不会占据字符串的位置
```

```javascript
var reg = /^2.3$/;
reg.test('2.3'); //=> true
reg.test('2+3'); //=> true 点在正则中的意思：匹配除了\n以外的任意字符，而不是单纯的小数点

reg = /^2\.3$/;
reg.test('2.3'); //=> true
reg.test('2+3'); //=> false 使用转义字符把点转换为本身小数点的意思
```

```javascript
var reg = /^\\$/;
reg.test('\\'); //=> true
```

`x|y`

```javascript
var reg = /^18|19$/; //=> 18 19 189 119 819 181 1819 ...很多都符合这个规则

/*
 * 18或者19
 * 以1开头 以9结尾 中间8或者1
 * 以18开头或者以19结尾即可 => '18ab' 'ab19'
*/

var reg = /^(18|19)$/; //=> 此时只有18或者19符合规则
reg.test('18'); //=> true
reg.test('19'); //=> true
reg.test('189'); //=> false
reg.test('1819'); //=> false
```

> `()`： 正则中的分组，也可以理解为一个大正则中的一个正则（包起来的部分是一个整体）；在正则中我们可以使用小括号`改变一些默认的优先级`；
> 
> 小分组还有第二个作用：`分组引用`
> 
> 小分组的第三个作用：`分组捕获`

```javascript
//=> 分组引用： \1 或者 \2 ... 出现和第N个分组一模一样的内容
var reg = /^([a-z])([a-z])\2([a-z])$/;
reg.test('food'); //=> true
reg.test('foad'); //=> false
reg.test('week'); //=> true
```

`[]`

> [xyz] [^xyz] [a-z] [^a-z]

```javascript
//=> \w: 数字字母下划线中的任意字符
var reg = /^[a-zA-Z0-9_]$/; //=> 等价于\w

//=> 中括号中出现的元字符，一般都代表本身的含义
var reg = /^[.?+&]+$/; //=> 里面的四个元字符都是本身含义，例如：点就是小数点，不是所谓的任意字符...

//=> 需求：描述这样的类名的规则（数字、字母、下划线、-）,并且不能以-或者数字开头
var reg = /^[a-zA-Z_][\w-]*$/;
```

```javascript
//=> 需求：验证18-65之间的年龄
var reg = /^[18-65]$/; //=> 1或者8~6或者5中的任意一个字符，中括号中出现的18不是数字18，而是1或者8，当前正则是非法的：因为不能设置8~6这种范围

//=> 分三个阶段
// 18 ~ 19  /(18|19)/
// 20 ~ 59  /([2-5]\d)/
// 60 ~ 65  /(6[0-5])/
var reg = /^((18|19)|([2-5]\d)|(6[0-5]))$/;
```

## 常用正则表达式

`验证是否为有效数字`

```javascript
/*
 * 可能是证书，可能是负数 12 -12
 * 正数或者小数 0 12 0.2 -12.3 
 * 只要出现小数点，后面至少要跟一位数字
*/

var reg = /^-?(\d|([1-9]\d+))(\.\d+)?$/;

/*
 * -? 负号可有可无
 * (\d|([1-9]\d+))
 *     \d 一位数可以是任意数字
 *     ([1-9]\d+) 多位数不能以0开头
 * (\.\d+)? 小数部分可有可无，有的话点后面必须跟一位数字
*/
```

`手机号码`

```javascript
/*
 * 11为数字
 * 1开头
 * 
*/
var reg = /^1\d{10}$/;
```

`用户名：真实姓名`

```javascript
//=> /^[\u4E00=\u9FA5]$/ 中文汉字的正则
var reg = /^[\u4E00=\u9FA5]{2,5}(·[\u4E00=\u9FA5]{2,5})?$/;
```

`邮箱`

```javascript
var reg =/^\w+((-\w+)|(\.\w+))*@[A-Za-z0-9]+((\.|-)[A-Za-z0-9]+)*\.[A-Za-z0-9]+$/; 

/*
 * 以数字字母下划线
 * @ 前面可以是数字、字母、下划线、-、·这些符号
 * 不能把-和· 连续出现，出现一次后面必须跟数字字母下划线 
 * @后面的部分支持
 *     企业邮箱
 *     .com.cn 多域名情况
*/
```

`身份证号码`

```javascript
/*
 * 18位
 * 前17为必须为数字
 * 最后一位可以是数字或者X(X代表数字10)
 * 
 * 220722199001010410
 *   前6位： 省市县 220722
 *   接下来8位： 出生年+月+日
 *   倒数第二位数字 奇数代表男 偶数代表女
*/
var reg = /^(\d{6})(\d{4})(\d{2})(\d{2})\d{2}(\d)(\d|X)$/;
//=> 这样写不仅可以匹配，而且以后再捕获的时候，不仅可以把大正则的结果捕获到，里面的每一个小分组（小正则）匹配的结果也可以单独的捕获到“分组捕获”

/=> 1950-2018
//=> 第一段 1950-1999
//=> 第二段 2000-2018
//=> 00~09
//=> 10-17

// /^(19[5-9]\d)|(20((0\d)|(1[0-7])))$/
```

### 正则捕获

> 把当前字符串中符合正则的字符捕获到
> RegExp.prototype: `exec` 实现正则捕获的方法

```javascript
var str = 'abcd2018abcdefg1234';
var reg = /\d+/;
reg.exec(str); //=> ["2018", index: 4, input: "abcd2018abcdefg1234", groups: undefined]

reg = /^\d+$/;
reg.exec(str); //=> null

/*
 * 当正则捕获的时候：
 * 1、先验证当前字符串和正则是否匹配，如果不匹配返回的结果是null（没有捕获到任何内容）
 * 2、如果匹配，从字符串最左边开始，向右边查找到匹配的内容，并且把匹配的内容返回
 * 
 * 
 * exec捕获到结果的格式：
 * -> 获取的结果是一个数组
 * -> 数组中的第一项是当前本次正则在字符串中匹配到的结果
 * -> index: 记录了当前本次捕获到结果的起始索引
 * -> input: 当前正则操作的原始字符串
 * -> 如果当前正则中有分组，获取的数组中，从第二项开始都是小分组本次匹配到的结果
 * 
 * 执行一次exec只能把符合正则规则条件的一个内容捕获到，如果还有其他符合规则的，需要再执行exec才有可能捕获到
*/
```

`正则捕获存在懒惰性`

> 执行一次exec捕获到第一个符合规则的内容，第二次执行exec捕获到的依然是第一次匹配的内容，后面匹配的内容不管执行多少次都无法捕获到
> 
> 解决正则捕获的懒惰性：
> 
> 在正则的末尾加修饰符g（全局匹配）

```javascript
var reg = /\d+/;
var str = 'abc2018defgh2020';
console.log(reg.lastIndex); //=> 0
reg.exec(str); //=> '2018'
console.log(reg.lastIndex); //=> 0
```

> 正则为什么会存在懒惰行？
> 
> 正则本身有一个属性：lastIndex（下一次正则在字符串中匹配查找的开始索引）
> 
> 默认值: 0 从字符串第一个字符开始查找匹配的内容，默认不管执行多少遍exec方法，正则额lastIndex值都不会变（也就是第一次以后查找的时候还是从第一个字符找，所以找到的结果永远都是第一个匹配的内容）
> 
> 且当我们手动修改lastIndex值的时候，不会起到任何作用

> 为什么加修饰符g就解决了懒惰性？
> 
> 加了修饰符g，每一次exec结束后，浏览器默认会把lastIndex值进行修改，下一次从上一次结束的位置开始查找，所以可以得到后面匹配的内容

```javascript
var reg = /\d+/g;
var str = 'abc2018defgh2020';
console.log(reg.lastIndex); //=> 0
console.log(reg.exec(str)); //=> '2018'

console.log(reg.lastIndex); //=> 3
console.log(reg.exec(str)); //=> '2020'

console.log(reg.lastIndex); //=> 12
console.log(reg.exec(str)); //=> null

console.log(reg.lastIndex); //=> 0
console.log(reg.exec(str)); //=> '2018'
```

> exec有自己的局限性：执行一次exec只能捕获到一个和正则匹配的结果（即使加了修饰符g），如果需要都捕获，我们需要执行N次exec方法才可以
> 
> 下面封装的myExecAll方法，目的是执行一次这个方法，可以把当前正则匹配到的全部内容都捕获到

```javascript
RegExp.prototype.myExecAll = function myExecAll(){
	//=> this:当前需要处理的正则
	var str = arguments[0] || '',
		result = [];
	//=> 首先判断this是否加了全局修饰符g，如果没有加，为了防止下面执行出现死循环，我们只让其执行exec即可，把执行一次的结果直接返回即可
	if(!this.global){
		return this.exec(str);
	}	
	
	var ary = this.exec(str);
	while (ary) { //=> ary !== null: 还可以继续捕获内容，我们继续下一次捕获
		result.push(ary[0]); //=> 把当前本次捕获到的结果存放在result数组中
		ary = this.exec(str);  //=> 继续执行下一次的捕获
	}
	return result;
};
var reg = /\d+/g;
console.log(reg.myExecAll('abc2018defgh2020'));
```

###使用字符串match实现捕获

> 1、如果正则加了修饰符g，执行一次match会把所有正则匹配的内容捕获到
> 
> 2、如果没有加修饰符g，执行一次match只能把第一个匹配的结果捕获到
> 
> 
> 局限性：加了修饰符g，执行match只能把大正则匹配的内容捕获到，对于小分组捕获的内容方法给其自动忽略

```javascript
var str = 'my name is {0}, i am {1} years old~';

//=> 需求：把{n}整体捕获到，而且还要把括号中的数字也获取到

var reg = /\{(\d+)\}/g;
str.match(reg); //=> ["{0}", "{1}"];

//=> 想要获取小分组的内容，只能使用exec处理

function fn(reg, str){
	var ary = reg.exec(str),
		result = [];
	while(ary){
		result.push(ary);
		ary = reg.exec(str);
	}
	return result;
}

```
