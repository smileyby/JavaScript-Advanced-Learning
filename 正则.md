正则
====

### 什么是正则？

> 正则就是一个规则，用来处理**`字符串`**的规则
> 
> 1、正则匹配
> 
> 编写一个规则，验证某个字符串是否符合这个规则，正则匹配使用的是test方法
> 
> 2、 正则捕获
> 
> 编写一个规则，在一个字符串中把符合规则的内容都获取到，正则捕获使用的方法：正则的exec方法、字符串中的split、replace、match等方法都支持正则

```javascript
var reg = /^$/; //=> 两个斜杠中间包含一些内容就是正则，两个斜杠之间包含的全部内容都是元字符
```

### 正则的元字符和修饰符

> 任何一个正则都是由元字符和修饰符组成的

`修饰符`

+ g(global): 全局匹配
+ i(ignoreCase): 忽略大小写匹配
+ m(multitle): 多行匹配

`元字符`

[量词元字符]

+： 让前面的元字符出现1到多次
?： 出现0到1次
*： 出现0到多次
{n}：出现n次
{n,}：出现n到多次
{n,m}：出现n到m次

[特殊意义的元字符]

\: 转义字符（把一个普通字符转变为特殊意义的字符，或者把一个有意义字符转换为普通的字符）
.:除了\n（换行符）以外的任意字符
\d: 匹配一个0-9之间的数字
\D: 匹配任意一个非0-9之间的数字（大写字母和小写字母的组合瞧好是反向的）
\w: 匹配一个`0-9或字母或_`之间的字符
\s: 匹配一个任意空白字符
\b: 匹配一个边界符
x|y: 匹配x或y中的一个
[a-z]: 匹配a-z中的任意一个字符
[^a-z]: 和上面的相反，匹配任意一个非a-z的字符
[xyz]: 匹配x或者y或者z中的任意一个字符
[^xyz]: 匹配除了xyz意外的任意字符
(): 正则的小分组，匹配一个小分组（小分组可以理解为大正则中的小正则）
^: 以某一个元字符开始
$: 以某一个元字符结束
?:：只匹配不捕获
?=: 正向预查
?!:负向预查
...

除了以上特殊字符和量词字符，齐钰的都叫做普通元字符：代表本身意义的元字符

### 元字符详细解读

`^ $`

```javascript
var reg = /\d+/; //=> 包含某某某即可
var str = 'abc2018-818';
reg.text(str); //=> true

reg = /^\d+/;
reg.test(str); //=> false

reg = /^\d+$/; //=> 只能是某某某的，这里说明只能是1到多个数字
reg.test(str); //=> false

reg.test('2018'); //=> true
reg.test('2018abc2018'); //=> false
reg.test('1'); //=> true //=> ^或$只是一个修饰或者声明，不会占据字符串的位置
```

```javascript
var reg = /^2.3$/;
reg.test('2.3'); //=> true
reg.test('2+3'); //=> true 点在正则中的意思：匹配除了\n以外的任意字符，而不是单纯的小数点

reg = /^2\.3$/;
reg.test('2.3'); //=> true
reg.test('2+3'); //=> false 使用转义字符把点转换为本身小数点的意思
```

```javascript
var reg = /^\\$/;
reg.test('\\'); //=> true
```

`x|y`

```javascript
var reg = /^18|19$/; //=> 18 19 189 119 819 181 1819 ...很多都符合这个规则

/*
 * 18或者19
 * 以1开头 以9结尾 中间8或者1
 * 以18开头或者以19结尾即可 => '18ab' 'ab19'
*/

var reg = /^(18|19)$/; //=> 此时只有18或者19符合规则
reg.test('18'); //=> true
reg.test('19'); //=> true
reg.test('189'); //=> false
reg.test('1819'); //=> false
```

> `()`： 正则中的分组，也可以理解为一个大正则中的一个正则（包起来的部分是一个整体）；在正则中我们可以使用小括号`改变一些默认的优先级`；
> 
> 小分组还有第二个作用：`分组引用`
> 
> 小分组的第三个作用：`分组捕获`

```javascript
//=> 分组引用： \1 或者 \2 ... 出现和第N个分组一模一样的内容
var reg = /^([a-z])([a-z])\2([a-z])$/;
reg.test('food'); //=> true
reg.test('foad'); //=> false
reg.test('week'); //=> true
```

`[]`

> [xyz] [^xyz] [a-z] [^a-z]

```javascript
//=> \w: 数字字母下划线中的任意字符
var reg = /^[a-zA-Z0-9_]$/; //=> 等价于\w

//=> 中括号中出现的元字符，一般都代表本身的含义
var reg = /^[.?+&]+$/; //=> 里面的四个元字符都是本身含义，例如：点就是小数点，不是所谓的任意字符...

//=> 需求：描述这样的类名的规则（数字、字母、下划线、-）,并且不能以-或者数字开头
var reg = /^[a-zA-Z_][\w-]*$/;
```

```javascript
//=> 需求：验证18-65之间的年龄
var reg = /^[18-65]$/; //=> 1或者8~6或者5中的任意一个字符，中括号中出现的18不是数字18，而是1或者8，当前正则是非法的：因为不能设置8~6这种范围

//=> 分三个阶段
// 18 ~ 19  /(18|19)/
// 20 ~ 59  /([2-5]\d)/
// 60 ~ 65  /(6[0-5])/
var reg = /^((18|19)|([2-5]\d)|(6[0-5]))$/;
```

## 常用正则表达式

`验证是否为有效数字`

```javascript
/*
 * 可能是证书，可能是负数 12 -12
 * 正数或者小数 0 12 0.2 -12.3 
 * 只要出现小数点，后面至少要跟一位数字
*/

var reg = /^-?(\d|([1-9]\d+))(\.\d+)?$/;

/*
 * -? 负号可有可无
 * (\d|([1-9]\d+))
 *     \d 一位数可以是任意数字
 *     ([1-9]\d+) 多位数不能以0开头
 * (\.\d+)? 小数部分可有可无，有的话点后面必须跟一位数字
*/
```

`手机号码`

```javascript
/*
 * 11为数字
 * 1开头
 * 
*/
var reg = /^1\d{10}$/;
```

`用户名：真实姓名`

```javascript
//=> /^[\u4E00=\u9FA5]$/ 中文汉字的正则
var reg = /^[\u4E00=\u9FA5]{2,5}(·[\u4E00=\u9FA5]{2,5})?$/;
```

`邮箱`

```javascript
var reg =/^\w+((-\w+)|(\.\w+))*@[A-Za-z0-9]+((\.|-)[A-Za-z0-9]+)*\.[A-Za-z0-9]+$/; 

/*
 * 以数字字母下划线
 * @ 前面可以是数字、字母、下划线、-、·这些符号
 * 不能把-和· 连续出现，出现一次后面必须跟数字字母下划线 
 * @后面的部分支持
 *     企业邮箱
 *     .com.cn 多域名情况
*/
```

`身份证号码`

```javascript
/*
 * 18位
 * 前17为必须为数字
 * 最后一位可以是数字或者X(X代表数字10)
 * 
 * 220722199001010410
 *   前6位： 省市县 220722
 *   接下来8位： 出生年+月+日
 *   倒数第二位数字 奇数代表男 偶数代表女
*/
var reg = /^(\d{6})(\d{4})(\d{2})(\d{2})\d{2}(\d)(\d|X)$/;
//=> 这样写不仅可以匹配，而且以后再捕获的时候，不仅可以把大正则的结果捕获到，里面的每一个小分组（小正则）匹配的结果也可以单独的捕获到“分组捕获”

/=> 1950-2018
//=> 第一段 1950-1999
//=> 第二段 2000-2018
//=> 00~09
//=> 10-17

// /^(19[5-9]\d)|(20((0\d)|(1[0-7])))$/
```
